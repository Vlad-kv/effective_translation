%{
    #include <cstdio>
    #include <ctype.h>
    #include <math.h>
    #include <iomanip>
    
    #include <vector>
    #include <string>
    
    using namespace std;
    
    #include "parser.h"
    #include "functional_grammar.h"

    int yylex();
    void yyerror(char const *);
%}

%union {
    double double_val;
    int int_val;
    
    char *char_ptr_val;
    string *string_ptr_val;
    vector<string> *str_vector_ptr_val;
    
    f_type *f_type_ptr_val;
}

%token <int_val> INT_NUM
%token <string_ptr_val> VAR_NAME

%token LET
%token IN
%token REC

%token UNIT
%token INT
%token STRING

%type <str_vector_ptr_val> var_arguments
%type <f_type_ptr_val> type

%right ARROW

%left '-' '+'
%left '*' '/'

%left NEG /* negation--unary minus */
%left '^' /* string concatenation */

%left APPLICATION

%% /* The grammar follows. */
    input : global_definitions
    ;
    global_definitions:
          /* empty */
        | global_definitions global_definition
    ;
    main_part_of_definition:
        VAR_NAME var_arguments ':' type '=' term {
            f_type_sp t($4);
            
            *output_stream << "definition:\n"
                << "  VAR_NAME: " << *$1 << "\n"
                << "  var_arguments: ";
            for (std::string& var : *$2) {
                *output_stream << var << " ";
            }
            *output_stream << "\n"
                << "  type: " << to_string(t) << "\n";
            delete $1;
            delete $2;
        }
    ;
    definition:
          LET main_part_of_definition
        | LET REC main_part_of_definition
    global_definition:
        definition ';' ';' {
        }
    ;
    local_definition:
        definition IN {
        }
    ;
    type:
          UNIT     { $$ = new f_type(nullptr, nullptr, "unit"  ); }
        | INT      { $$ = new f_type(nullptr, nullptr, "int"   ); }
        | STRING   { $$ = new f_type(nullptr, nullptr, "string"); }
        | VAR_NAME { $$ = new f_type(nullptr, nullptr, *$1     );
                     delete $1; }
        | type ARROW type {
            $$ = new f_type(f_type_sp($1), f_type_sp($3));
          }
        | '(' type ')' { $$ = $2; }
    ;
    term:
          '(' ')' // unit
        | '(' term ')'
        | VAR_NAME
        | term '+' term
        | term '-' term
        | term '*' term
        | term '/' term
        | term '^' term
        | term term %prec APPLICATION
        | INT_NUM
        | local_definition term
    ;
    var_arguments:
          /* empty */ {
            $$ = new vector<string>();
        }
        | var_arguments VAR_NAME {
            $1->push_back(move(*$2));
            $$ = $1;
            delete $2;
        }
    ;
%%
