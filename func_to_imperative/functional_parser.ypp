%{
    #include <cstdio>
    #include <ctype.h>
    #include <math.h>
    #include <iomanip>
    
    #include <vector>
    #include <string>
    
    #include "parser.h"

    int yylex();
    void yyerror(char const *);
%}

%union {
    double double_val;
    int int_val;
    
    char *char_ptr_val;
    std::string *string_ptr_val;
    std::vector<std::string> *str_vector_ptr_val;
}

%token <int_val> INT_NUM
%token <string_ptr_val> VAR_NAME

%token LET

%type <str_vector_ptr_val> arguments
%type <int_val> global_defenitions

//%type <double_val> exp
//%type <double_val> line

%left '-' '+'
%left '*' '/'

%left NEG /* negation--unary minus */
%right '^' /* exponentiation */

%% /* The grammar follows. */
    global_defenitions:
        /* empty */
        | global_defenitions definition
    ;
    definition:
        LET VAR_NAME arguments '=' INT_NUM ';' ';' {
            *output_stream << "definition: " << *$2 << "   ";
            for (std::string& var : *$3) {
                *output_stream << var << " ";
            }
            *output_stream << "\n";
            delete $2;
            delete $3;
        }
    ;
    arguments:
        /* empty */ {
            $$ = new std::vector<std::string>();
        }
        | arguments VAR_NAME {
            $1->push_back(std::move(*$2));
            $$ = $1;
            delete $2;
        }
    ;
    input:
        VAR_NAME {
            *output_stream << "VAR_NAME: " << *$1 << "\n";
            delete $1;
        }
    ;
%%

/*
    input: // empty
        | input line
    ;
    line: '\n'
        | exp '\n' { *output_stream << "  " << std::setprecision(10) << $1 << "\n"; }
    ;
    exp: NUM { $$ = $1; }
        | exp '*' exp { $$ = $1 * $3; }

        | exp '+' exp { $$ = $1 + $3; }
        | exp '-' exp { $$ = $1 - $3; }
        
        | exp '/' exp { $$ = $1 / $3; }
        | '-' exp %prec NEG { $$ = -$2; }
        | exp '^' exp { $$ = pow ($1, $3); }
        | '(' exp ')' { $$ = $2; }
    ;
*/
