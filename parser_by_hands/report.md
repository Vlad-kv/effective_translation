### Ручное построение нисходящего парсера, вариант 2 (регулярные выражения)
###### Исходная грамматика:
* R -> O|R
* R -> O
* O -> CO
* O -> e
* C -> C\*
* C -> c
* C -> (R)

Где 
* R - регулярное выражение (в том числе и стартовый нетерминал).
* C - регулярное выражение в скобках, символ латинского алфавита, либо замыкание Клини С.
* O - последовательность С, возможно пустая.

Содержит правое ветвление (правила *R -> O|R* и *R -> O*) и левую рекурсию (правило *C -> C\**).

Избавимся от этого. Новая грамматика:
* R -> OR'
* R' -> e
* R' -> |R
* O -> CO
* O -> e
* C' -> \*C'
* C' -> e
* C -> (R)C'

Где
* R - то же самое.
* R' - последовательность состоящая из |O (возможно пустая).
* O - то же самое.
* C - (регулярное выражение в скобках или символ латинского алфавита) и последовательность их замыканий (возможно пустая).
* C' - последовательность символов \* (возможно пустая).

###### Множество FIRST для нетерминалов:
* FIRST(R) = {|, c, (, e}
* FIRST(R') = {e, |}
* FIRST(O) = {e, c, (}
* FIRST(C) = {c, (}
* FIRST(C') = {e, \*}
###### Множество FOLLOW для нетерминалов:
* FOLLOW(R) = {$, )}
* FOLLOW(R') = {$, )}
* FOLLOW(O) = {$, ), |}
* FOLLOW(C) = {$, (, ), c, |}
* FOLLOW(C') = {$, (, ), c, |}

Обозначим за T(A -> a) множество (FIRST(a) - *e*) (+ FOLLOW(A) если *e* не принадлежит FIRST(a)), где *A -> a* - правило вывода, *A* - нетерминал, *a* - последовательность терммналов и нетерминалов. Посчитаем T() для каждого правила в новой грамматике:
* T(*R -> OR'*) = {$, (, ), c, |}
* T(*R' -> e*) = {$, )}
* T(*R' -> |R*) = {|}
* T(*O -> CO*) = {(, c}
* T(*O -> e*) = {$, ), |}
* T(*C' -> \*C'*) = {\*}
* T(*C' -> e*) = {$, (, ), c, |}
* T(*C -> (R)C'*) = {(}

По доказанной теореме, чтобы грамматика была LL(1) н. и д., чтобы множества T() для правил вывода из одинаковых нетерминалов не пересекались.

Видно, что в данном случае так и есть, и тогда новая грамматика - LL(1).
