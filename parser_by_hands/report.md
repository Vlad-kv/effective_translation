### Ручное построение нисходящего парсера, вариант 2 (регулярные выражения)
###### Исходная грамматика:
* R -> R|O
* R -> O
* O -> OC
* O -> e
* M -> *
* M -> +
* M -> ?
* C -> CM
* C -> c
* C -> (R)

Где 
* R - регулярное выражение (в том числе и стартовый нетерминал).
* M - 'модификатор' - замыкание Клини, + или ?.
* C - регулярное выражение в скобках, символ латинского алфавита, либо модификатор применённый к С.
* O - последовательность С, возможно пустая.

Содержит левые рекурсии (правило *C -> CM*, правило *R -> R|O*, правило *O -> OC*).

Избавимся от этого. Новая грамматика:
* R' -> |OR'
* R' -> e
* R -> OR'
* O' -> CO'
* O' -> e
* O -> O'
* M -> *
* M -> +
* M -> ?
* C' -> MC'
* C' -> e
* С -> cC'
* C -> (R)C'

Где
* R - то же самое.
* R' - последовательность состоящая из |O (возможно пустая).
* O - O' 
* M - то же самое.
* O' - последовательность С, возможно пустая.
* C - (регулярное выражение в скобках или символ латинского алфавита) и последовательность их модификаторов (возможно пустая).
* C' - последовательность M (возможно пустая).

###### Множество FIRST для нетерминалов:
* FIRST(R)  = {e, (, c, |}
* FIRST(R') = {e, |}
* FIRST(O)  = {e, (, c}
* FIRST(O') = {e, (, c}
* FIRST(C)  = {(, c}
* FIRST(C') = {e, \*, +, ?}
* FIRST(M)  = {\*, +, ?}
###### Множество FOLLOW для нетерминалов:
* FOLLOW(R)  = {$, )}
* FOLLOW(R') = {$, )}
* FOLLOW(O)  = {$, ), |}
* FOLLOW(O') = {$, ), |}
* FOLLOW(C)  = {$, (, ), c, |}
* FOLLOW(C') = {$, (, ), c, |}
* FOLLOW(M)  = {$, (, ), *, +, ?, c, |}

Обозначим за T(A -> a) множество (FIRST(a) - *e*) (+ FOLLOW(A) если *e* не принадлежит FIRST(a)), где *A -> a* - правило вывода, *A* - нетерминал, *a* - последовательность терммналов и нетерминалов. Посчитаем T() для каждого правила в новой грамматике:
* T(*R' -> |OR'*) = {|}
* T(*R' -> e*)    = {$, )}
* T(*R -> OR'*)   = {$, (, ), c, |}
* T(*O' -> CO'*)  = {(, c}
* T(*O' -> e*)    = {$, ), |}
* T(*O -> O'*)    = {$, (, ), c, |}
* T(*C' -> MC'*)  = {*, +, ?}
* T(*C' -> e*)    = {$, (, ), c, |}
* T(*M -> ?*)     = {?}
* T(*M -> +*)     = {+}
* T(*M -> \**)    = {*}
* T(*С -> cC'*)   = {c}
* T(*C -> (R)C'*) = {(}

По доказанной теореме, чтобы грамматика была LL(1) н. и д., чтобы множества T() для правил вывода из одинаковых нетерминалов не пересекались.

Видно, что в данном случае так и есть, и тогда новая грамматика - LL(1).
