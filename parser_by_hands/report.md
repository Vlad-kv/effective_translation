### Ручное построение нисходящего парсера, вариант 2 (регулярные выражения)
###### Исходная грамматика:
* R -> O|R
* R -> O
* O -> CO
* O -> e
* C -> C\*
* C -> c
* C -> (R)

Где 
* R - регулярное выражение (в том числе и стартовый нетерминал).
* C - регулярное выражение в скобках, символ латинского алфавита, либо замыкание Клини С.
* O - последовательность С, возможно пустая.

Содержит правое ветвление (правила *R -> O|R* и *R -> O*) и левую рекурсию (правило *C -> C\**).

Избавимся от этого. Новая грамматика:
* R -> OR'
* R' -> e
* R' -> |R
* O -> CO
* O -> e
* C' -> \*C'
* C' -> e
* C -> (R)C'

Где
* R - то же самое.
* R' - последовательность состоящая из |O (возможно пустая).
* O - то же самое.
* C - (регулярное выражение в скобках или символ латинского алфавита) и последовательность их замыканий (возможно пустая).
* C' - последовательность символов \* (возможно пустая).

###### Множества FIRST и FOLLOW для нетерминалов:
* FIRST(R) = {|, c, (, e}, SECOND(R) = {$, )}
* FIRST(R') = {e, |},      SECOND(R') = {$, )}
* FIRST(O) = {e, c, (},    SECOND(O) = {$, ), |}
* FIRST(C) = {c, (},       SECOND(C) = {$, (, ), c, |}
* FIRST(C') = {e, \*},      SECOND(C') = {$, (, ), c, |}

Обозначим за T(A -> a) множество (FIRST(a) - *e*) (+ FOLLOW(A) если *e* не принадлежит FIRST(a)), где *A -> a* - правило вывода, *A* - нетерминал, *a* - последовательность терммналов и нетерминалов. Посчитаем T() для каждого правила в новой грамматике:
* T(*R -> OR'*) = {$, (, ), c, |}
* T(R' -> e) = {$, )}
* T(R' -> |R) = {|}
* T(O -> CO) = {(, c}
* T(O -> e) = {$, ), |}
* T(C' -> \*C') = {\*}
* T(C' -> e) = {$, (, ), c, |}
* T(C -> (R)C') = {(}

По доказанной теореме, чтобы грамматика была LL(1) н. и д., чтобы множества T() для правил вывода из одинаковых нетерминалов не пересекались.

Видно, что в данном случае так и есть, и тогда новая грамматика - LL(1).
